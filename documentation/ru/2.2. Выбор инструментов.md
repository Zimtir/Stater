_В данном документе представлен пункт 2.1 из раздела **Глава 2**_

# Выбор инструментов

Для реализации проекта необходимо определиться с инструментами и обосновать их использование. Так как, в конце концов, это влияет на дальнейшую поддержку и легкость в тестировании. Технологии постоянно меняются, не имеет смысл использовать что-то устаревшее, так как найти разработчиков для поддержки из года в год, для постоянно устаревающего программного обеспечения всё сложнее и сложнее.

Стоит начать с выбора технологий для клиентской части, которой будет пользоваться конечный пользователь системы. В современном мире нужно учесть пользовательский опыт и интерфейсы для легкости понимания контента и управления им. Самым популярным решением для клиентской части является веб-ресурсы, к которым легко получить доступ с персонального компьютера или смартфона.
Также использование веб-ресурсов в качестве клиентской части позволяет сэкономить при разработке мобильных приложений, так как, к примеру, Google, который является вендором для платформы Android, открыл доступ к Progressive Web Applications (PWA) внутри своего магазина мобильных приложений Play Market, что позволяет создать конфигурационный файл для веб-ресурса и тем самым обеспечить доступ к конечной системе, в том числе с помощью смартфона на операционной системе Android. Но не стоит забывать, что огромное количество девайсов сейчас имеет операционную систему iOS, чьим владельцем являтеся Apple, который не позволяет так просто использовать PWA, обходным решением являются кросс-платформенный код, который можно написать на одном языке программирования и использовать везде, такими являются платформы .NET, Java, Kotlin, JavaScript и другие.

Вся клиентская часть использует преимущественно JavaScript, который поддерживают почти все современные браузеры, в отличии от остальных языков, которые в той или иной степени, используют генерацию представления на серверной части платформы (Server-Side Rendering). Тем не менее, страницы получаются не такими динамичными, как если бы использовался JavaScript.
Ключевой проблемой JavaScript является отсутствие типизации в языке, эта проблема демонстрируе, в основном сложности, которые связаны с проверкой полученных данных, к примеру определение пришедших значений, таких как строки и числа, иногда, особенно при использовании монетизации или учёте каких-либо денежных средств, это может привести к неправильному расчёту значений. К счастью эту проблему решает обёртка TypeScript, которую представила на рынке компания Microsoft.

Помимо выбора кросс-платформенного решения с строгой типизацией, необходимо реализовать постоянный приток данных с сервера, который также может быть написан с использованием серверных инструментов, таких как Node.js и Socket.io. Первая технология является реализацией обработки запросов на сервере, вторая работает, как на клиентской, так и на серверной части и реализует систему доставки без перезагрузки страницы, к примеру, через long-pooling или web sockets.

Данные необходимо где-то хранить, существуют решения табличного вида или документоориентированного. Выбор одного из этих решений заключается в твёрдой уверенности какими данными мы собираемся обладать и насколько они формализуемы, также от этого зависит скорость обработки данных и организация хранения. Можно выбрать кластеризованные решения, такие как Cassandra или Hadoop, но они требуют высокого уровня квалификации, представляя масштабируемую и распределённую систему для хранения и обработки данных. Так как, в нашем случае, данных огромное количество, то стоит обратить внимание в сторону Cassandra или реляционную базу данных в виде MySQL из-за широкой распространённости и простоты использования, а также непривязанности к одной из платформ, как, например, MS SQL и .NET платформа от компании Microsoft.

Server-Side Rendering (SSR) позволяет уменьшить нагрузку на конечного клиента и часть контента сгенерировать на серверной части, а значит необходимо расширить выбор библиотек для написания сервера. Таким решением является Sapper.js, который включает в себя кроме SSR и Node.js ещё и Svelte.js, что отвечает за пользовательское представление на клиентской части.
Svelte.js сравнительно молодая библиотека и уже зарекомендовала себя на рынке, как высокопроизводительный фреймворк, исключающий построение виртуального дерева, что активно используется крупными библиотеками, например, React.js от Facebook. Помимо этого, Svelte.js включает в себя упрощённую работу с анимациями и клиенсткими данными, которые не требуют постоянных запросов к серверной части.

Для того чтобы упростить работу связи между серверной и клиентской частью подойдёт современная технология под названием Service Workers, которые позволяют минимизировать количество запросов при нестабильном соединении клиента и сервера, кешируя их или выдывая какие-либо заранее обработанные данные.

Так как код написанный с использованием всех этих библиотек не будет работать просто так, его необходимо превратить в один конечный ресурс, который можно передать на обработку браузеру и/или серверу. В данном случае будет использоваться такая технология, как Rollup.js, созданная тем же разработчиком, что создал Sapper.js. Она необходима в связи с тем, что браузер не может обработать TypeScript и нам нужно транспилировать его в JavaScript перед использованием браузером.

Стоит обратить внимание на безопасность используемого серверного решения и использовать не просто Node.js, а изолированную среду под названием Deno.js, она лишает серверную часть от лишних доступов к файловой системе используемой операционной системы.

Для полноценного тестирования продукта, также необходимо использовать unit или интеграционные тесты, по идее это маленькие программы, которые нацелены на проверку того, что каждый элемент системы работает как ожидалось. Для реализации тестирования подойдёт библиотека Jest.js и браузер без визуального представления Puppeteer.js, который является терминальным доступом к браузеру на ядре Chromium. Puppeteer.js позволяет воспроизвести шаги клиента в рамках тестирования по заданному поведению и убедиться, что клиентская часть реагирует на эти шаги, как ожидалось в соответствии с заложенным планом действий. Оба этих решения позволяют покрыть проект интеграционными и unit тестами.

При финализации решения, стоит учесть, что на рынке активно используется методология Agile, которая представляет из себя итерационное производство системы, когда проект делится на итерации, где публикуется часть функционала, подводя сырой или минимально жизнеспособный продукт (MVP) к стабильному ресурсу с обновлениями, в зависимости от постоянно меняющихся требований. Для того, чтобы обеспечить стабильную выгрузку версий потребуется использовать конвейрную систему, которая будет являться как хранилещем кодовой базы, так и построением и сборкой новых версий.
Решений на рынке, которые позволяют это сделать, довольно, много. Но стоит смотреть в сторону экономии финансовых средств, так что ресурс GitHub, который представляет бесплатное хранение и конвейрную сборку продукта, как в приватном виде, так и в публичном.

Финальным этапом в выборе инструментов является контейнеризация проекта. Что позволит без постоянной перенастройки системы адаптировать её к запуску на любой ОС. Такие решения представляет продукт под названием Docker, он позволяет изолировать всё приложение в контейнер и запустить его без дополнительных установок программного обеспечения. Для масштабируемости контейнера, в зависимости от доступных ресурсов, нагрузки на сеть и прочих элементов, стоит использовать такую технологию, как Kubernetes, она позволяет объединять контейнеры в кластеризированную систему с оркестрацией. Также необходимо учесть проксирование запросов для безопасности сервера, где подойдёт технология с открытым доступом Nginx.

Итоговым список инструментов являются следующие:

Клиентская часть:

- Svelte.js
- Socket.io
- Service workers
- TypeScript

Серверная часть:

- Deno.js
- Sapper.js
- Rollup.js
- Jest.js
- Puppeeter.js
- Socket.io
- TypeScript
- Cassadnra/MySQL
- Nginx
- Kubernetes
- Docker

Для генерации графических представлений воспользуемся сервисом Graphana, который можно запустить с помощью Docker и подключить его к существующей базе данных, на основе которой сгенерируем небольшие диаграммы, максимально исключающие круговые, так как они менее информативны.
